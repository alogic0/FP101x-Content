1
00:00:00,919 --> 00:00:05,140
Bem-vindos de volta!
Espero que todos tenham instalado o GHC

2
00:00:05,140 --> 00:00:08,599
e brincado um pouco digitando 
expressões.

3
00:00:08,599 --> 00:00:13,330
O que iremos fazer agora é ir
além de simples expressões

4
00:00:13,330 --> 00:00:18,350
e ver como podemos carregar
programas Haskell completos  

5
00:00:18,350 --> 00:00:23,310
no GHC. 
Em Haskell, programas não são chamados

6
00:00:23,310 --> 00:00:27,260
programas. Normalmente pessoas do Haskell
referem-se a seus códigos 

7
00:00:27,260 --> 00:00:30,689
como scripts porque

8
00:00:30,689 --> 00:00:34,190
programas em Haskell são, talvez,
mais curtos do que código normal.

9
00:00:34,190 --> 00:00:37,730
Eu apenas os chamo de programas 
Haskell,

10
00:00:37,730 --> 00:00:41,550
mas a linguagem em haskell

11
00:00:41,550 --> 00:00:44,899
é scripts.

12
00:00:44,899 --> 00:00:50,610
Novas funções, se vocês querem
definir um programa completo em Haskell,

13
00:00:50,610 --> 00:00:53,870
defina elas em um

14
00:00:53,870 --> 00:00:57,170
arquivo texto que contenha uma lista de
definições de funções

15
00:00:57,170 --> 00:01:00,840
e este arquivo texto

16
00:01:00,840 --> 00:01:06,040
tenha um sufixo .hs que indica
que é um

17
00:01:06,040 --> 00:01:10,170
arquivo Haskell.
Igual um arquivo HTML tem um

18
00:01:10,170 --> 00:01:14,340
.html sufixo, ou arquivos CSS tem 

19
00:01:14,340 --> 00:01:17,890
sufixo .css, ou arquivo Java

20
00:01:17,890 --> 00:01:21,350
tem um sufixo .java,

21
00:01:21,350 --> 00:01:25,000
um arquivo Haskell é chamado 
qualquer coisa

22
00:01:25,000 --> 00:01:29,049
.hs. Isso não é obrigatório,

23
00:01:29,049 --> 00:01:32,320
mas é útil que vocês possam ver quando 

24
00:01:32,320 --> 00:01:35,689
listarem os arquivos em um diretório
possam ver que 

25
00:01:35,689 --> 00:01:40,210
é um script Haskell. 
Agora quando vocês

26
00:01:40,210 --> 00:01:44,430
estiverem usando o GHC,

27
00:01:44,430 --> 00:01:47,530
o que vocês fazem é editar o seu

28
00:01:47,530 --> 00:01:52,049
script em uma janela, usando qualquer
editor de sua escolha,

29
00:01:52,049 --> 00:01:55,259
e então sempre que vocês fizerem uma alteração,
carreguem seu

30
00:01:55,259 --> 00:01:59,460
script no seu GHC e comecem

31
00:01:59,460 --> 00:02:03,590
executar expressões.
Então, este é o tipo de fluxo

32
00:02:03,590 --> 00:02:07,369
que usaremos na maioria do curso.
Para coisas simples

33
00:02:07,369 --> 00:02:12,080
isso é o que vocês fazem. Claro, quando estiverem
construindo aplicações comerciais em Haskell

34
00:02:12,080 --> 00:02:13,420
não é assim que vocês fazem.

35
00:02:13,420 --> 00:02:16,450
Vocês compilarão eles em executáveis
standalone,

36
00:02:16,450 --> 00:02:21,550
mas para o propósito deste curso, este
é o fluxo: temos

37
00:02:21,550 --> 00:02:25,950
a janela do editor aberta, temos o 
interpretador GHCi aberto

38
00:02:25,950 --> 00:02:30,150
e então carregaremos os scripts.
Neste caso,

39
00:02:30,150 --> 00:02:33,880
criaremos um

40
00:02:33,880 --> 00:02:37,140
arquivo texto test.hs e nele

41
00:02:37,140 --> 00:02:40,840
definimos duas funções.
A primeira:

42
00:02:40,840 --> 00:02:45,380
dobro de x igual a x + x
- faz o que promete -

43
00:02:45,380 --> 00:02:49,890
e então podemos quadruplicar
chamando double de double de x.

44
00:02:49,890 --> 00:02:55,459
Então salvamos aquele arquivo
e iniciamos o

45
00:02:55,459 --> 00:02:59,690
GHCi invocando o ele com

46
00:02:59,690 --> 00:03:04,400
test.hs e agora ambas as bibliotecas
padrão Haskell quanto

47
00:03:04,400 --> 00:03:08,220
as funções quadruple e
double que definimos

48
00:03:08,220 --> 00:03:12,030
no test.hs estarão disponíveis.
Por exemplo, podemos chamar

49
00:03:12,030 --> 00:03:13,500
quadruple de 10

50
00:03:13,500 --> 00:03:16,819
e retornará 40, mas podemos também

51
00:03:16,819 --> 00:03:21,049
ainda chamar todas as funções da
biblioteca padrão. Por exemplo

52
00:03:21,049 --> 00:03:24,660
podemos pegar

53
00:03:24,660 --> 00:03:30,070
o dobro de 2 desta lista. Dobro de 2 é
4, então isto é o mesmo que pegar 4,

54
00:03:30,070 --> 00:03:30,650


55
00:03:30,650 --> 00:03:33,820
então pegamos os primeiros 4 
elementos da lista.

56
00:03:33,820 --> 00:03:39,200
O que fazemos agora

57
00:03:39,200 --> 00:03:44,540
é deixar o GHC aberto, retornamos
ao nosso editor e 

58
00:03:44,540 --> 00:03:47,579
adicionamos

59
00:03:47,579 --> 00:03:51,290
2 novas definições: uma é factorial

60
00:03:51,290 --> 00:03:56,750
e a outra é average.
Visto que estamos começando aqui,

61
00:03:56,750 --> 00:04:01,180
estamos usando alguma sintaxe
que não introduzimos ainda, então

62
00:04:01,180 --> 00:04:04,380
tenham paciência. 
O produto

63
00:04:04,380 --> 00:04:08,100
de 1 até n - esta coisa aqui

64
00:04:08,100 --> 00:04:11,840
é a lista de valores de 1 até n -

65
00:04:11,840 --> 00:04:16,070
e então product é uma função
da biblioteca padrão

66
00:04:16,070 --> 00:04:19,169
que multiplica todos os valores
em uma lista, assim

67
00:04:19,169 --> 00:04:24,330
esta é uma boa definição de fatorial.
Quando queremos calcular a

68
00:04:24,330 --> 00:04:25,480
média

69
00:04:25,480 --> 00:04:29,350
de uma lista nós somamos

70
00:04:29,350 --> 00:04:33,780
todos os elementos - os valores dos elementos -
e então dividimos

71
00:04:33,780 --> 00:04:38,020
pelo comprimento da lista.
Claro, esta não é uma implementação 

72
00:04:38,020 --> 00:04:41,780
muito inteligente de média, mas isso
não importa... não estamos

73
00:04:41,780 --> 00:04:45,750
aqui para definir a função average,
estamos fazendo isso para aprender

74
00:04:45,750 --> 00:04:51,220
GHCi. A coisa que estamos usando aqui é
este truque aqui em Haskell

75
00:04:51,220 --> 00:04:55,280
é que quando vocês colocam o nome de
uma função 

76
00:04:55,280 --> 00:04:59,390
entre estas aspas simples,

77
00:04:59,390 --> 00:05:02,580
isso torna-se um operador infixo.

78
00:05:02,580 --> 00:05:06,290
Então, se vocês escreverem

79
00:05:06,290 --> 00:05:09,620
x `f` y

80
00:05:09,620 --> 00:05:12,900
isto é realmente apenas "syntactic sugar"
para

81
00:05:12,900 --> 00:05:18,410
f x y. Algumas pessoas gostam destas coisas
como um operador infixo,

82
00:05:18,410 --> 00:05:21,640
outras gostam apenas como um operador
regular

83
00:05:21,640 --> 00:05:25,690
- fica a sua escolha. 
Isto é "syntactic convention".
Então isto não é 

84
00:05:25,690 --> 00:05:26,960
uma string ou qualquer cosa,

85
00:05:26,960 --> 00:05:31,440
é realmente pegar uma função e retornar
em um operador infixo.

86
00:05:31,440 --> 00:05:35,290
Então no GHCi, chamamos reload

87
00:05:35,290 --> 00:05:39,020
e ele irá ler o arquivo

88
00:05:39,020 --> 00:05:42,920
test.hs, adicione todos os novos vínculos
que definimos

89
00:05:42,920 --> 00:05:46,410
- esta era para o factorial, agora podemos
chamar factorial

90
00:05:46,410 --> 00:05:49,610
e então podemos chamar average também.

91
00:05:49,610 --> 00:05:54,520
Aqui vocês veêm o fluxo:
vocês tem o seu GHCi aberto, seu editor

92
00:05:54,520 --> 00:05:58,360
vocês editam, chamam reload, e assim 
podem testar

93
00:05:58,360 --> 00:06:03,430
vocês códigos. 
Algums coisas 

94
00:06:03,430 --> 00:06:07,960
sintáticas, ou esquisitices em Haskell:
nomes de 

95
00:06:07,960 --> 00:06:12,480
funções e paramêtros deve começar com
letra

96
00:06:12,480 --> 00:06:15,730
minúscula.

97
00:06:15,730 --> 00:06:19,530
Se vocês definem uma função, ela deve

98
00:06:19,530 --> 00:06:23,010
ser de qualquer uma dessa formas.
Mas qualquer uma dessas

99
00:06:23,010 --> 00:06:26,720
começam com uma letra 

100
00:06:26,720 --> 00:06:30,580
minúscula. Vocês podem usar aspas
simples

101
00:06:30,580 --> 00:06:34,310
se forem muito preguiçoso para
inventar um nome. Isso é 

102
00:06:34,310 --> 00:06:37,950
algo que eu muita vezes sinto falta em 
outras linguagens, onde eu apenas quero dizer

103
00:06:37,950 --> 00:06:38,710
x prime ou

104
00:06:38,710 --> 00:06:42,520
x double prime, etc.

105
00:06:42,520 --> 00:06:47,210
Se vocês definem um tipo, um tipo
tem que começar com 

106
00:06:47,210 --> 00:06:51,710
nome maiúsculo e este é o 
motivo. Em Haskell,

107
00:06:51,710 --> 00:06:55,130
os tipos e identificadores

108
00:06:55,130 --> 00:06:58,180
estão em namespaces diferentes e isso
é determinado

109
00:06:58,180 --> 00:07:01,620
se ele começa com um identificador
minúsculo or

110
00:07:01,620 --> 00:07:05,540
maiúsculo. Isso pode ser 
confuso se vocês vierem de uma linguagem

111
00:07:05,540 --> 00:07:06,830
diferente como 

112
00:07:06,830 --> 00:07:10,990
Java, ou C# ou JavaScript.

113
00:07:10,990 --> 00:07:15,000
Outra coisa é que em
Haskell usamos

114
00:07:15,000 --> 00:07:19,800
uma forma muito suave de notação
húgara.

115
00:07:19,800 --> 00:07:22,930
Se um paramêtro tem um

116
00:07:22,930 --> 00:07:27,700
sufixo s, então por exemplo se
vocês tem um paramêtro nomeado

117
00:07:27,700 --> 00:07:31,420
xs ou ns ou nss,

118
00:07:31,420 --> 00:07:35,840
isso significa uma lista de valores

119
00:07:35,840 --> 00:07:39,640
do tipo x e esta é uma lista de
valores

120
00:07:39,640 --> 00:07:44,460
do tipo n - as vezes o n não corresponde
ao nome

121
00:07:44,460 --> 00:07:49,360
to tipo - mas normalmente quando vocês vêem um
s no final vocês sabem que é uma lista.

122
00:07:49,360 --> 00:07:52,460
Se existir 2 s's no final
- como aqui -

123
00:07:52,460 --> 00:07:55,910
vocês sabem que é uma lista de listas.

124
00:07:55,910 --> 00:07:59,630
Isso é por convenção. Assim, se vocês querem
parecer como programadores Haskell de verdade,

125
00:07:59,630 --> 00:08:03,370
vocẽs deveriam sempre usar esta convenção.
Quando seu paramêtro é uma lista,

126
00:08:03,370 --> 00:08:07,250
ele sempre terminar com s, e normalmente

127
00:08:07,250 --> 00:08:10,410
identificadores Haskeel são curtos

128
00:08:10,410 --> 00:08:13,900
assim, vocês não chamem ele de elements,
vocês chamem de xs.

129
00:08:13,900 --> 00:08:17,510
Uma outra

130
00:08:17,510 --> 00:08:21,370
coisa interessante que Haskell tem em 
comum com Python

131
00:08:21,370 --> 00:08:25,050
é que espaços em branco são significantes.
As

132
00:08:25,050 --> 00:08:28,100
regras exatas são bastantes sutis, 
mas

133
00:08:28,100 --> 00:08:32,350
estamos apenas usando Haskell

134
00:08:32,350 --> 00:08:35,630
de uma forma bem simples, 
então isso

135
00:08:35,630 --> 00:08:40,880
é o sufficient. Se vocês tem uma
sequência de definições - como aqui -

136
00:08:40,880 --> 00:08:44,600
elas todas tem que iniciar na mesma
coluna. Aqui

137
00:08:44,600 --> 00:08:47,760
a, b e c, todas começam 

138
00:08:47,760 --> 00:08:51,230
na mesma coluna.
Neste caso aqui,

139
00:08:51,230 --> 00:08:55,300
b tem um espaço no seu lado esquerdo,

140
00:08:55,300 --> 00:08:58,780
assim, agora todas essas definições não começam
na mesma coluna.

141
00:08:58,780 --> 00:09:01,860
Isso está errado!
Ou neste caso, c

142
00:09:01,860 --> 00:09:04,990
e a não iniciam na mesma coluna como b..

143
00:09:04,990 --> 00:09:08,130
também errado.

144
00:09:08,130 --> 00:09:11,460
Espaço em branco é significante em Haskell,

145
00:09:11,460 --> 00:09:15,600
então, certifique-se que todas suas definições
estão alinhadas - isso é chamado de regra de layout.

146
00:09:15,600 --> 00:09:19,290
A regra the layout

147
00:09:19,290 --> 00:09:22,660
existe para evitar escrever

148
00:09:22,660 --> 00:09:26,080
sintaxe desnecessária.
Os caras de Haskell

149
00:09:26,080 --> 00:09:30,050
gostam de escrever isto:
a = b + c where

150
00:09:30,050 --> 00:09:33,510
e então na cláusula where temos
uma lista de definições que

151
00:09:33,510 --> 00:09:37,230
começam todas na mesma coluna e então 
d

152
00:09:37,230 --> 00:09:40,440
aqui inicia na mesma coluna como a,

153
00:09:40,440 --> 00:09:44,060
então isso pertence ao mesmo grupo
como a.

154
00:09:44,060 --> 00:09:47,950
Vocês podem escrever isto com 
chaves e ponto

155
00:09:47,950 --> 00:09:51,920
e vírgula explicitos
- se vocês quiserem -

156
00:09:51,920 --> 00:09:55,700
mas isso parece muito mais 

157
00:09:55,700 --> 00:09:59,850
verboso. 
Programadores Haskell gostam de 
brevidade,

158
00:09:59,850 --> 00:10:03,110
então, eles usarão com frequência
espaços em brancos.

159
00:10:03,110 --> 00:10:06,640
Isto parece um pouco idiota.

160
00:10:06,640 --> 00:10:10,520
In the Haskell world, when you write code like
this people will look like

161
00:10:10,520 --> 00:10:14,090
"you didn't do enough wax on, wax off".

162
00:10:14,090 --> 00:10:21,090
Here's some GHC commands that are
useful

163
00:10:21,220 --> 00:10:24,330
and I really

164
00:10:24,330 --> 00:10:29,620
invite you to play around with it
When you do the exercises for

165
00:10:29,620 --> 00:10:33,220
subsequent lectures, make sure that you
leverage

166
00:10:33,220 --> 00:10:36,800
GHC or whatever other compiler you use,

167
00:10:36,800 --> 00:10:41,930
to help you. We have seen
reload, but you can also just

168
00:10:41,930 --> 00:10:45,820
load a fresh script.

169
00:10:45,820 --> 00:10:49,050
From the interpreter

170
00:10:49,050 --> 00:10:52,430
you can open the editor, so you can edit

171
00:10:52,430 --> 00:10:56,270
a file with a certain name, 
or edit the current script.

172
00:10:56,270 --> 00:10:59,880
This one here is super useful:

173
00:10:59,880 --> 00:11:03,550
it gives the type of an expression and I do
this

174
00:11:03,550 --> 00:11:08,330
all the time - I never write types myself. 
I ask what the type is and I go

175
00:11:08,330 --> 00:11:11,589
in the editor and paste in the type.

176
00:11:11,589 --> 00:11:15,959
You definitely should use :?

177
00:11:15,959 --> 00:11:19,649
and that gives you a list of all the
commands

178
00:11:19,649 --> 00:11:23,970
with a small explanation. 
Of course,

179
00:11:23,970 --> 00:11:27,350
I hope that you will not use this

180
00:11:27,350 --> 00:11:31,079
last command to quit GHC,

181
00:11:31,079 --> 00:11:34,450
but that you will, for the next
eight weeks,

182
00:11:34,450 --> 00:11:39,709
be constantly using GHC.

183
00:11:39,709 --> 00:11:43,010
There will be a lot of exercises

184
00:11:43,010 --> 00:11:46,660
and the exercises will be on the website.

185
00:11:46,660 --> 00:11:49,680
All these exercises,

186
00:11:49,680 --> 00:11:54,510
you should be able to
do them in any language. You don't

187
00:11:54,510 --> 00:11:55,600
have to use

188
00:11:55,600 --> 00:11:59,990
GHC, but in this case, since this lecture
is about

189
00:11:59,990 --> 00:12:03,029
GHC, they will be

190
00:12:03,029 --> 00:12:06,610
GHC-specific. 
In general,

191
00:12:06,610 --> 00:12:10,680
as I said in the very first lecture, this
is a course

192
00:12:10,680 --> 00:12:15,430
about functional programming. It's not a
course about Haskell and it's definitely

193
00:12:15,430 --> 00:12:17,320
not a course about GHC,

194
00:12:17,320 --> 00:12:22,020
but in this specific case the exercises for
this chapter and

195
00:12:22,020 --> 00:12:25,250
for this lecture are on GHCi.

196
00:12:25,250 --> 00:12:29,459
Happy hacking and 
see you all next week!

